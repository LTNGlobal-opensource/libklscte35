/*
 * Copyright (c) 2016 Kernel Labs Inc. All Rights Reserved
 *
 * Address: Kernel Labs Inc., PO Box 745, St James, NY. 11780
 * Contact: sales@kernellabs.com
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <libklscte35/scte35.h>

#if 0
static void hexdump(unsigned char *buf, unsigned int len, int bytesPerRow /* Typically 16 */)
{
	for (unsigned int i = 0; i < len; i++)
		printf("%02x%s", buf[i], ((i + 1) % bytesPerRow) ? " " : "\n");
	printf("\n");
}
#endif

/* Mouse:
   Out of network:
   <SCTE35 command="5" command_str="insert" pts_adjustment="67521" event_id="692" cancel="0"
      out_of_network="1" program_splice="1" splice_time="immediate" unique_program_id="1">
*/
static uint8_t mouse_oon[] = {
	0xfc, 0x30, 0x1b, 0x00, 0x00, 0x00, 0x01, 0x07,
	0xc1, 0x00, 0xff, 0xf0, 0x0a, 0x05, 0x00, 0x00,
	0x02, 0xb4, 0x7f, 0xdf, 0x00, 0x01, 0x01, 0x01,
	0x00, 0x00, 0x7c, 0x18, 0x5d, 0x61
};

/*
   Mouse:
   Back to network:
   <SCTE35 command="5" command_str="insert" pts_adjustment="67521" event_id="693" cancel="0"
      out_of_network="0" program_splice="1" splice_time="2241430756" unique_program_id="1">
*/
static uint8_t mouse_btn[] = {
	0xfc, 0x30, 0x20, 0x00, 0x00, 0x00, 0x01, 0x07,
	0xc1, 0x00, 0xff, 0xf0, 0x0f, 0x05, 0x00, 0x00,
	0x02, 0xb5, 0x7f, 0x4f, 0xfe, 0x85, 0x99, 0x84,
	0xe4, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x3e,
	0x17, 0xd8, 0x2e 
};

/* These were copied from the test cases for the Comcast GOTS project (BSD licensed).  The
   original
   sources can be found here:
   https://github.com/Comcast/gots/blob/master/scte35/scte35_test.go

   Note:  I changed the arrays to strip off the leading byte, and apparently the
   test vectors had incorrect checksums (the GoTS library itself doesn't ever attempt
   to validate the checksums).  Hence I've modified the sections to have valid checksums
*/
static uint8_t comcast_gots_test1 [] = {
	0xfc, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xf0, 0x05, 0x06, 0xfe, 0x86,
	0xdf, 0x75, 0x50, 0x00, 0x11, 0x02, 0x0f, 0x43,
	0x55, 0x45, 0x49, 0x41, 0x42, 0x43, 0x44, 0x7f,
	0x8f, 0x00, 0x00, 0x10, 0x01, 0x01, 0xce, 0x6d,
	0x6a, 0x49,
};

static uint8_t comcast_gots_test2 [] = {
	0xfc, 0x00, 0x53, 0x00, 0x00, 0x00, 0x02, 0xdd,
	0x20, 0x00, 0xff, 0xf0, 0x05, 0x06, 0xfe, 0x00,
	0x08, 0x95, 0x44, 0x00, 0x3d, 0x02, 0x3b, 0x43,
	0x55, 0x45, 0x49, 0x00, 0x00, 0x00, 0x02, 0x7f,
	0x1f, 0x02, 0x01, 0xfe, 0x00, 0x2d, 0xd2, 0x00,
	0x02, 0xfe, 0x00, 0x00, 0x01, 0xe8, 0x09, 0x1f,
	0x53, 0x49, 0x47, 0x4e, 0x41, 0x4c, 0x3a, 0x59,
	0x38, 0x6f, 0x30, 0x44, 0x33, 0x7a, 0x70, 0x54,
	0x78, 0x53, 0x30, 0x4c, 0x54, 0x31, 0x65, 0x77,
	0x2b, 0x77, 0x75, 0x69, 0x77, 0x3d, 0x3d, 0x36,
	0x00, 0x00, 0xbf, 0x68, 0xb8, 0xc0,
};

static uint8_t comcast_gots_test3 [] = {
	0xfc, 0x30, 0x55, 0x00, 0x00, 0x00, 0x02, 0xd5,
	0xa0, 0x00, 0xff, 0xf0, 0x05, 0x06, 0xfe, 0x00,
	0x04, 0x2b, 0x79, 0x00, 0x3f, 0x02, 0x1b, 0x43,
	0x55, 0x45, 0x49, 0x00, 0x00, 0x00, 0x01, 0x7f,
	0x87, 0x09, 0x0c, 0x53, 0x49, 0x47, 0x4e, 0x41,
	0x4c, 0x3a, 0x33, 0x2e, 0x30, 0x35, 0x30, 0x35,
	0x01, 0x01, 0x02, 0x20, 0x43, 0x55, 0x45, 0x49,
	0x00, 0x00, 0x00, 0x01, 0x7f, 0xff, 0x00, 0x00,
	0x23, 0x13, 0xac, 0x09, 0x0c, 0x53, 0x49, 0x47,
	0x4e, 0x41, 0x4c, 0x3a, 0x33, 0x2e, 0x30, 0x35,
	0x30, 0x34, 0x01, 0x01, 0x70, 0x51, 0x15, 0x6c,
};

static int parse(uint8_t *sec, int byteCount)
{
	printf("\nParsing a new SCTE35 section......\n");
	struct scte35_splice_info_section_s *s = scte35_splice_info_section_parse(sec, byteCount);
	if (s) {

		/* Dump struct to console */
		scte35_splice_info_section_print(s);

		/* Free the allocated resource */
		scte35_splice_info_section_free(s);
	}

	return 0;
}

int parse_main(int argc, char *argv[])
{
	parse(&mouse_oon[0], sizeof(mouse_oon));
	parse(&mouse_btn[0], sizeof(mouse_btn));

	/* Samples from Comcast GoTs project */
	parse(&comcast_gots_test1[0], sizeof(comcast_gots_test1));
	parse(&comcast_gots_test2[0], sizeof(comcast_gots_test2));
	parse(&comcast_gots_test3[0], sizeof(comcast_gots_test3));

	printf("program complete.\n");
	return 0;
}
